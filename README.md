# fairBench-tiny

This is a high-performance C++ utility for evaluating basic fairness metrics from large tabular datasets.  

It provides a lightweight alternative to the [**FairBench**](https://github.com/mever-team/FairBench) Python framework for bias and fairness assessment. This variation is ideal for environments where speed and memory efficiency are critical by streaming through a file and accumulating values without loading all data in memory.

## âœ¨ Features

- Fast parsing of large CSV/TSV files with bare metal code.  
- Aggregate group-wise metrics for classification (tpr, tnr, accuracy, pr).
- Color-coded output and exit codes for failing analysis. 
- Minimal energy footprint in a few kB of memory - set up as a worker.
- Expressive arguments that can be read from *.fb* scripts to revisit complicated analysis.
- Streaming interface.

## âš¡ Quickstart

Download the *./fbt* executable from the project's 
[latest release](https://github.com/maniospas/fairbench-tiny/releases/latest).
If you have an issue, want to contribute, or your platform is not supported, clone this repository and run `make`. This will create the executable `build/fbt`.

Run the executable:

```bash
./fbt data.csv [--label colname] [--predict colname] [--threshold value] [--members min_count]
```

- data.csv Path to the CSV/TSV data file to analyze. If no path is provided, *fbt* polls stdin every 100ms to provide live updates.
- --label &lt;colname> Name of the column containing true labels (default: *label*).
- --predict &lt;colname> Name of the column containing predicted labels (default: *predict*).
- --threshold &lt;value> Highlight values below this fairness threshold in red, and above 1-threshold in green (default: 0.0).
- --numbers &lt;value> Declares that numerical data columns with less than the number of distinct values should be treated as categorical. For example, you might have values 1,2,3 for marital status, where the identifiers are explained elsewhere.
- --members &lt;min_count> Minimum number of samples required for a group to be included in the fairness report. Groups with fewer members are ignored.
- --stream &lt;rows> Stream an update after every fixed number of seconds. If this is set and no path is provided, you get live
updates from *stdin*.
- @&lt;NAME> Switches to declaring column-specific characteristics. These are presented next.
- --numerical Indicates that the column holds numerical data (this is prioritized over the globally set --numbers).
- --skip Ignores the column during parsing.

## ðŸª„ Script files

You might have complex arguments in your run that would be a shame to lose.
In those cases, pass as the only argument a configuration *.fb* file like the ones in *examples/*. 
Scripts can be accompanied by command line arguments, but this behavior is not 
well-defined right now in case of conflicts - usually you will see an error.

Run script files like below (you can still provide arguments externally, but these are overwritten by
file-specific options):

```bash
./fbt examples/credit.fb
```

Here is an example script, where code highlighting comes from a VScode extension (look for fairbench).
The outcome reports only on the columns of interest.

<div style="display: flex; justify-content: center; gap: 1rem; flex-wrap: wrap;">
  <figure style="text-align: center;">
    <img src="examples/fbt_script.png" alt="Example Script" width="400" style="border-radius: 8px;"><br>
    <figcaption>Example script (shown by the <i>FairBench Tiny Syntax</i> extension in VSCode)</figcaption>
  </figure>
  <br>
  <figure style="text-align: center;">
    <img src="examples/fbt_results.png" alt="Outcome Report" width="400" style="border-radius: 8px;"><br>
    <figcaption>Outcome fairness report generated by the script</figcaption>
  </figure>
</div>


## ðŸ“˜ Expected Input

The first line must contain column headers (group names, *label*, and *predict*). Columns may be separated by **comma `,`**, **tab `\t`**, or **semicolon `;`** â€” the first delimiter encountered is used. **Whitespace** or quotations are ignored everywhere.  

All rows must have the same number of columns as the header, and must contain categorical or numerical data values at every column. For predictions and labels, if no column scpecifications are provided, values are considered binary identified by whether column entries start with
*y*, *Y*, or *1*.

```csv
gender,region,label,predict
1,0,1,1
0,0,0,0
1,1,1,0
0,1,0,1
```

## Streaming interface

You can monitor an algorithm while it is running by having it flush predictions in *stdout*.
For example, in Linux you can pipe the outcome like below. The example use a Python script 
to demonstrate an algorithm outputting results.

```python
# examples/streamer.py
import time
import sys
import random

# --- Write header ---
sys.stdout.write("gender,region,label,predict\n")
sys.stdout.flush()

while True:
    gender = random.choice(["man", "woman", "other"])
    region = random.choice(["here", "there", "everywhere", "nowhere"])
    label = random.choice(["0", "1"])
    predict = random.choice(["0", "1"])
    sys.stdout.write(f"{gender},{region},{label},{predict}\n")

    if random.random() < 0.05:
        sys.stdout.flush() # randomly flush for demonstration
    time.sleep(0.01) # mimics a slow algorithm (not needed)
```

```bash
python3 examples/streamer.py | ./fbt --stream 0.1
```